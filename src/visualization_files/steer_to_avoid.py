# -*- coding: utf-8 -*-
"""steer_to_avoid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10imqZFb9oqJhy_9j-g3yaeyNIQYER5Zd
"""

import math

def steer_to_avoid(grid_map, boid,max_steering_angle,neighborhood_radius,step_angle ):
    boid_x, boid_y, boid_theta = boid
    steering_adjustment = 0

    lookahead_x = boid_x + neighborhood_radius * math.cos(math.radians(boid_theta))
    lookahead_y = boid_y + neighborhood_radius * math.sin(math.radians(boid_theta))

    grid_x = int(lookahead_x)
    grid_y = int(lookahead_y)
    print("check", grid_x, grid_y)
    i = 0
    while grid_map[grid_y][grid_x] == 100 and abs(steering_adjustment) <= max_steering_angle:
        print("busy cell", grid_x, grid_y)

        # Try adding the step_angle
        steering_adjustment += step_angle
        new_theta = boid_theta + steering_adjustment
        print("added angle", new_theta)

        new_grid_x = int(boid_x + neighborhood_radius * math.cos(math.radians(new_theta)))
        new_grid_y = int(boid_y + neighborhood_radius * math.sin(math.radians(new_theta)))

        if grid_map[new_grid_y][new_grid_x] != 100:
            print("free cell", new_grid_x, new_grid_y)
            boid_theta = new_theta
            break

        # Try subtracting the step_angle
        new_theta = boid_theta - steering_adjustment
        print("sub angle", new_theta)

        new_grid_x = int(boid_x + neighborhood_radius * math.cos(math.radians(new_theta)))
        new_grid_y = int(boid_y + neighborhood_radius * math.sin(math.radians(new_theta)))

        if grid_map[new_grid_y][new_grid_x] != 100:
            print("free cell", new_grid_x, new_grid_y)
            boid_theta = new_theta
            print("--", i)
            break

        i += 1

    return boid_theta

import matplotlib.pyplot as plt
import numpy as np
import math

def plot_initial_and_resulting_angles(grid_map, initial_boid, resulting_theta,neighborhood_radius):
    # Create a grid map plot
    plt.matshow(grid_map)
    plt.colorbar()
    plt.xlabel('Original Grid Map', fontsize=16)

    # Plot initial position
    plt.plot(initial_boid[0], initial_boid[1], 'bo', label='Initial Position')

    # Plot arrow representing the initial angle
    initial_angle_rad = math.radians(initial_boid[2])

    end_x = initial_boid[0] + neighborhood_radius * math.cos(initial_angle_rad)
    end_y = initial_boid[1] + neighborhood_radius * math.sin(initial_angle_rad)

    plt.arrow(initial_boid[0], initial_boid[1], end_x - initial_boid[0], end_y - initial_boid[1],
              head_width=5, head_length=5, fc='g', ec='g', label='Initial Angle')

    # Plot arrow representing the resulting angle after avoidance
    resulting_angle_rad = math.radians(resulting_theta)

    end_x_result = initial_boid[0] + neighborhood_radius * math.cos(resulting_angle_rad)
    end_y_result = initial_boid[1] + neighborhood_radius * math.sin(resulting_angle_rad)

    plt.arrow(initial_boid[0], initial_boid[1], end_x_result - initial_boid[0], end_y_result - initial_boid[1],
              head_width=5, head_length=5, fc='r', ec='r', label='Resulting Angle after Avoidance')

    plt.legend()
    plt.show()

max_steering_angle = 60
neighborhood_radius = 50
step_angle = 10
path = "/content/circle_10x10.npy"
grid_map =(1- np.loadtxt(path)) *100

initial_boid = (100,50,90)  # (x, y)
result = steer_to_avoid(grid_map, initial_boid,max_steering_angle,neighborhood_radius,step_angle)
print("Resulting steering adjustment:", result)
plot_initial_and_resulting_angles(grid_map, initial_boid, result,neighborhood_radius)